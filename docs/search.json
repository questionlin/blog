[{"title":"mysql运维","url":"/posts/1529389113/","content":"### SHOW STATUS\nshow status 命令会显示每个服务器变量和值，可以执行以下命令单个查看：\n```\nshow status where Variable_name like 'Conne%'\n```\n以下是一下重要的：\n\n#### 线程和连接统计\n- Connections, Max_used_connections, Threads_connected\n- Aborted_clients, Aborted_connects\n- Bytes_received, Bytes_sent\n- Slow_lanuch_threads, Threads_cached, Threads_created,\nThreads_running\n\n如果Aborted_connects不为0，可能意味着网络有问题或某人尝试连接但失败（可能用户指定了错误的密码或无效的数据库，或某个监控系统正在打开TCP的3306端口来检测服务器是否活着）。如果这个值太高，可能有严重的副作用：导致MySQL阻塞一个主机。\n\n#### 二进制日志状态\nBinlog_cache_use和Binlog_cache_disk_use状态变量显示了在二进制日志缓存中有多少事务被存储过，以及多少事务因超过二进制日志缓存而必须存储到一个临时文件中。\n\n#### SELECT类型\nSelect_*\b 变量是特定类型 SELECT 查询的计数器。其中Select_scan表示全表扫描，Select_range_check 和 Select_full_join 表示\b无索引的联接。这三个开销较大。\n\n#### 表锁\nTable_locks_immediate和Table_locks_waited变量可告诉你有多少锁被立即授权，有多少锁需要等待。但请注意，它们只是展示了服务器级别锁的统计，并不是存储引擎级的锁统计。\n\n### SHOW ENGINE INNODB STATUS\n显示 InnoDB 引擎的信息，只有一列。因为不是专业运维，这里只介绍几个需要了解的段。\n\n#### LATEST DETECTED DEADLOCK\n只有当前服务器内有死锁时才会出现，内容是死锁的上下文\n\n### SHOW PROCESSLIST\n进程列表是当前连接到MySQL的连接或线程的清单。**这个命令可以看哪些线程持有锁**\n\n--------------------------\n参考资料：《高性能MySQL》","tags":["运维"]},{"title":"mysql explain 中各列的意义","url":"/posts/1529374970/","content":"### id 列\n查询编号，从外到内的顺序递增，临时表的 id 为 NULL。\n\n### select_type 列\n这一列显示是哪种类型的 SELECT。最外层是 PRIMARY，其他部分标记如下：\n- SUBQUERY\n  包含在SELECT列表中的子查询中的SELECT（换句话说，不在FROM子句中）\n\n- DERIVED\n  包含在 FROM 子句的子查询中的SELECT。MySQL 会产生一个临时表。\n\n- UNION\n  在 UNION 中的第二个和随后的 SELECT。\n\n- UNION RESULT\n  用来从UNION的匿名临时表检索结果的SELECT被标记为UNION RESULT\n\n### table 列\n这一列显示了对应行正在访问哪个表。\n\n当在FROM子句中有子查询时，table列是<derivedN>的形式，其中N是子查询的id。这总是“向前引用”——换言之，N指向EXPLAIN输出中后面的一行。\n\n当有UNION时，UNION RESULT的table列包含一个参与UNION的id列表。这总是“向后引用”，因为UNION RESULT出现在UNION中所有参与行之后。\n\n### type 列\n访问类型，就是 MySQL 决定如何查找表中的行。下面一次从最差到最优：\n- ALL\n  全表扫描\n\n- index\n  索引扫描，也要扫描全表，只是按照索引次序进行而不是行，避免了排序。\n\n- range\n  范围查询是一个有限制的索引扫描。WHERE 里带 BETWEEN 或 > <的查询。\n\n- ref\n  索引访问。叫 ref 是因为索引要跟某个参考值比较。ref_or_null 是 ref 的一个变体，它意味着 MySQL 必须进行第二次查找以找出 NULL 条目。\n\n- eq_ref\n  使用主键或唯一索引\n\n- const, system\n  MySQL 对语句优化后，变量被转为常量\n\n- NULL\n  只通过索引，不用访问数据表\n\n### possible_keys 列\n这一列显示了查询可以使用哪些索引，不一定真的用到。\n\n### key 列\n这一列显示了 MySQL 决定采用那个索引。\n\n### key_len 列\n该列显示了索引的字节数，不是表中数据的字节数。\n\n### ref 列\n这一列显示了之前的表在key列记录的索引中查找值所用的列或常量。\n\n### rows 列\n这一列是 MySQL 估计为了找到目标要读取的行数。不是最终目标行数。\n\n### filtered 列\nrows 占总行数的比例\n\n### Extra 列\n- Using index\n  表示 MySQL 使用覆盖索引，不需要访问数据表\n\n- Using where\n  WHERE 条件使用了索引\n\n- Using temporary\n  使用了临时表\n\n- Using filesort\n  使用了外部索引排序\n\n- Range checked for each record (index map: N)\n  没有好用的索引\n\n\n--------------------------\n参考资料：《高性能MySQL》","tags":["mysql"]},{"title":"用python做爬虫的正确姿势","url":"/posts/1529320519/","content":"已经用 python 做了不知道多少爬虫了，看看网上关于这个题材的文章都已经很老了，这篇文章介绍下我的做法。\n\n一个爬虫程序至少需要抓取和解析两个部分，抓取我使用的是 [requests](https://github.com/requests/requests)。这个库除了封装 get, post 请求外，尤其方便的是封装了会话( session )，自动更新 cookies。对抓取需要登录的网站特别好用。\n\n解析我使用的是 [pyquery](https://github.com/gawel/pyquery)。这个库对 jQuery 达到了很高的模仿，熟悉 jQuery 的人上手非常快。通常我都是在浏览器的 console 里复制 html 元素的 css 选择器或者 xpath 路径。这里要注意浏览器会给选择器添加元素，例如 tbody，复制出来是 table > tbody > tr。但其实 html 里没有 tbody 这个元素。手动去掉就好了。\n\n----------------------\n此外 python 还有一个重量级的爬虫库叫 scrapy。这个以前会用，现在已经很少用了。如果是大工程可以考虑。","tags":["python"]},{"title":"golang开发环境搭建","url":"/posts/1529303379/","content":"### 安装\nMac 下安装 Go 编译器只要执行\n```\nbrew install go\n```\n就可以了。各 linux 也可以使用自己的包管理器直接安装\n\n### 工作空间\n首先找一个地方放我们的工作空间，比如我选的是$HOME/Documents/gowork。这个目录的位置不能是 Go 安装目录。\n```\n$ mkdir $HOME/Documents/gowork\n```\nGo代码必须放在工作空间内。它其实就是一个目录，其中包含三个子目录：\n- src 目录包含Go的源文件，它们被组织成包（每个目录都对应一个包），\n- pkg 目录包含包对象，\n- bin 目录包含可执行命令。\n\n下面是一个例子：\n```\nbin/\n    hello       # 编译好的二进制文件，可执行命令\npkg/\n    darwin_amd64/\n        github.com/questionlin/\n            stringutil.a      # 编译好的包对象\nsrc/\n    github.com/questionilin/\n        hello/\n            hello.go        # 源代码\n            hello_test.go   # 测试文件源代码\n        stringutil/\n            reverse.go      # 包源码\n\n```\n\n### \bGOPATH 环境变量\n执行下面的命令\n```\n$ export GOPATH=$HOME/gowork\n$ export PATH=$PATH:$GOPATH/bin\n```\n\n### 第一个程序\n我在 github 的用户名是 questionlin，我要做的第一个程序叫 hello。执行命令\n```\n$ mkdir -p $GOPATH/src/github.com/questionlin/hello\n$ cd $GOPATH/src/github.com/questionlin/hello\n$ touch hello.go\n```\n写入一下代码\n```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Printf(\"Hello, world.\\n\")\n}\n```\n执行一下命令编译。这个命令在任何目录都可以执行，不需要在工作空间\n```\n$ go install github.com/questionlin/hello\n```\n如果在工作空间可以省略路径\n```\n$ cd $GOPATH/src/github.com/questionlin/hello\n$ go install\n```\n现在执行看看\n```\n$ $GOPATH/bin/hello\nHello, world.\n```\n\n### 第一个库\n首先创建目录：\n```\n$ mkdir $GOPATH/src/github.com/questionlin/stringutil\n$ cd $GOPATH/src/github.com/questionlin/stringutil\n$ touch reverse.go\n```\n写入一下内容\n```\n// stringutil 包含有用于处理字符串的工具函数。\npackage stringutil\n\n// Reverse 将其实参字符串以符文为单位左右反转。\nfunc Reverse(s string) string {\n\tr := []rune(s)\n\tfor i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n\t\tr[i], r[j] = r[j], r[i]\n\t}\n\treturn string(r)\n}\n```\n使用 go build 来编译:\n```\n$ go build github.com/questionlin/stringutil\n```\n如果你在该包的源码目录中，只需执行：\n```\n$ go build\n```\n修改原来的 hello.go 文件，加入这个包：\n```\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/questionlin/stringutil\"\n)\n\nfunc main() {\n\tfmt.Printf(stringutil.Reverse(\"!oG ,olleH\"))\n}\n```\n然后在编译一次 hello：\n```\n$ go install github.com/questionlin/hello\n```\n现在再运行一次\n```\n$ hello\nHello, Go!\n```\n完成以上步骤后，你的工作区间应该是像最上面介绍工作空间那章里一样\n\n\n### 包名\nGo源文件中的第一个语句必须是\n```\npackage 名称\n```\n这里的 名称 即为导入该包时使用的默认名称。 （一个包中的所有文件都必须使用相同的 名称。）\n\nGo的约定是包名为导入路径的最后一个元素：作为 “crypto/rot13” 导入的包应命名为 rot13。\n\n可执行命令必须使用 package main。\n\n### 测试\nGo拥有一个轻量级的测试框架，它由 go test 命令和 testing 包构成。\n\n你可以通过创建一个名字以 _test.go 结尾的，包含名为 TestXXX 且签名为 func (t *testing.T) 函数的文件来编写测试。 测试框架会运行每一个这样的函数；若该函数调用了像 t.Error 或 t.Fail 这样表示失败的函数，此测试即表示失败。\n\n我们可通过创建文件 $GOPATH/src/github.com/questionlin/stringutil/reverse_test.go 来为 stringutil 添加测试，其内容如下：\n```\npackage stringutil\n\nimport \"testing\"\n\nfunc TestReverse(t *testing.T) {\n\tcases := []struct {\n\t\tin, want string\n\t}{\n\t\t{\"Hello, world\", \"dlrow ,olleH\"},\n\t\t{\"Hello, 世界\", \"界世 ,olleH\"},\n\t\t{\"\", \"\"},\n\t}\n\tfor _, c := range cases {\n\t\tgot := Reverse(c.in)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"Reverse(%q) == %q, want %q\", c.in, got, c.want)\n\t\t}\n\t}\n}\n```\n接着使用 go test 运行该测试：\n```\n$ go test github.com/questionlin/stringutil\nok  \tgithub.com/questionlin/stringutil 0.165s\n```\n\n\n最后给一个墙内能用的 golang 学习教程：\nhttps://tour.go-zh.org/list\n\n参考：https://go-zh.org/doc/\n","tags":["golang"]},{"title":"linux磁盘满了怎么清理","url":"/posts/1528685621/","content":"1. 使用 df -h 查看磁盘剩余空间\n2. 使用 du --max-depth=1 -h 一级一级查看磁盘文件占用，找到适合删掉的文件\n3. 如果是只想删掉大文件，可以使用 find . -maxdepth 1 -size +100M\n```\n#df -h\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/vda1        30G   12G   17G  40% /\ndevtmpfs        7.8G     0  7.8G   0% /dev\n/dev/vdb         99G   55G   39G  59% /opt\n\n\n#du --max-depth=1 -h\n272K ./.gconf \n32K ./.mcop \n16K ./.redhat \n1.7M ./.thumbnails \n8.0K ./.gconfd \n7.5M . \n\n#find . -maxdepth 1 -size +100M\n./.gconf \n./.mcop \n./.redhat \n./.thumbnails \n./.gconfd \n```","tags":["运维"]},{"title":"MySQL索引结构和优化","url":"/posts/1528513470/","content":"### B-Tree 索引\nInnoDB 使用的是B+Tree，即每一个叶子结点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。B-Tree通常意味着所有的值都是按**顺序**存储在叶子节点的，并且每一个叶子页到根的距离相同。\n\n假设有如下数据表：\n```\nCREATE TABLE People (\n    last_name varchar(50)    not null,\n    first_name varchar(50)   not null,\n    dob date                 not null,\n    gender enum('m', 'f')  not null,\n    key(last_name, first_name, dob)\n);\n```\n可以使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找。**其中键前缀查找只适用于根据最左前缀的查找**。此索引对如下类型的查询有效。\n\n- 全值匹配\n  全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找 last_name 为 Allen, first_name 为 Cuba 、出生于1960-01-01的人。\n\n- 匹配最左前缀  \n索引可用于查找所有 lat_name 为Allen的人，即只使用索引的第一列。\n\n- 匹配列前缀  \n也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只使用了索引的第一列。\n\n- 匹配范围值  \n例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。\n\n- 精确匹配某一列并范围匹配另外一列  \n前面提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头（比如Kim、Karl等）的人。即第一列last_name全匹配，第二列frst_name范围匹配。\n\n#### B-Tree索引的限制：\n- 如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。\n- 不能跳过索引中的列。也就是说，前面所述的索引无法用于查找姓为Smith并且在某个特定日期出生的人。如果不指定名（first_name），则MySQL只能使用索引的第一列。\n- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询WHERE last_name='Smith' AND frst_name LIKE 'J％' AND dob='1976-12-23'，这个查询只能使用索引的前两列，因为这里LIKE是一个范围条件（但是服务器可以把其余列用于其他目的）。如果范围查询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件。在本章的索引案例学习部分，我们将演示一个详细的案例。\n\n到这里读者应该可以明白，前面提到的索引列的顺序是多么的重要：这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。\n\n### 高性能索引策略\n#### 独立的列\n**索引列不能是表达式的一部分，也不能是函数的参数。** 以下是失败例子：\n```\nmysql> SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;\nmysql> SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;\n```\n\n#### 前缀索引和索引选择性\n有时候需要索引很长的字符列，这会让索引变得大且慢。\b诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长。  \n现在我们有如下数据集\n```\nmysql>SELECT COUNT(*) AS cnt, city FROM city GROUP BY city ORDER BY cnt DESC LIMIT 10;\n-------------------------------------\n| cnt | city|\n+-----+-----+\n| 65 | London |\n| 49 | Hiroshima |\n| 48 | Teboksary |\n| 48 | Pak Kret |\n| 48 | Yaound |\n| 47 | Tel Aviv-Jaffa |\n| 47 | Shimoga |\n| 45 | Cabuyao |\n| 45 | Callao |\n| 45 | Bislig |\n```\n注意到，上面每个值都出现了45～65次。现在查找到最频繁出现的城市前缀，先从3个前缀字母开始：\n```\nmysql>SELECT COUNT(*) AS cnt, LEFT(city, 3) AS pref FROM city GROUP BY pref ORDER BY cnt DESC LIMIT 10;\n| cnt | pref |\n+-----+------+\n| 483 | San |\n| 195 | Cha |\n| 177 | Tan |\n| 167 | Sou |\n| 163 | al- |\n| 163 | Sal |\n| 146 | Shi |\n| 136 | Hal |\n| 130 | Val |\n| 129 | Bat |\n```\n每个前缀都比原来的城市出现的次数更多，因此唯一前缀比唯一城市要少得多。然后我们增加前缀长度，直到这个前缀的选择性接近完整列的选择性。经过实验后发现前缀长度为7时比较合适：\n```\nmysql>SELECT COUNT(*) AS cnt, LEFT(city, 3) AS pref FROM city GROUP BY pref ORDER BY cnt DESC LIMIT 10;\n| cnt | pref |\n+-----+------+\n| 70 | Santiag |\n| 68 | San Fel |\n| 65 | London |\n| 61 | Valle d |\n| 49 | Hiroshi |\n| 48 | Teboksa |\n| 48 | Pak Kre |\n| 48 | Yaound |\n| 47 | Tel Avi |\n| 47 | Shimoga |\n```\n计算合适的前缀长度的另外一个办法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。下面显示如何计算完整列的选择性：\n```\nmysql> SELECT COUNT(DISTINCT LEFT(city, 7))/COUNT(*) FROM city;\n| COUNT(DISTINCT city)/COUNT(*) |\n+-------------------------------+\n| 0.0310 |\n```\n通常来说（尽管也有例外情况），这个例子中如果前缀的选择性能够接近0.031，基本上就可用了。\n\n在上面的示例中，已经找到了合适的前缀长度，下面演示一下如何创建前缀索引：\n```\nmysql> ALTER TABLE sakila.city_demo ADD KEY (city(7));\n```\n前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。\n\n\n--------------------------\n参考资料：《高性能MySQL》","tags":["mysql"]},{"title":"Hello World","url":"/posts/1528164216/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"JVM 垃圾处理的一些总结","url":"/posts/1528196487/","content":"## 内存管理\n### 程序计数器\n程序计数器（Program Counter Register），用来记录程序已经执行到的行号，当虚拟机在多个线程轮流切换时，靠它回到正确的执行位置。\n\n### 堆和栈\nJava 内存可以大致分为：分为虚拟机栈，本地方法栈，Java 堆，方法区，运行时常量池，直接内存。各自用来存储虚拟机和用户程序的代码、变量和其他一些信息。其中，Java 堆是所有线程共享的一块内存区域，唯一目的时存放对象实例。因此也成为垃圾管理的主要区域。\n\n## 垃圾收集\n### 判断对象是否需要被清理\n判断对象是否需要被清理可以分为引用计数算法和可达性分析算法。\n\n引用计数算法的原理是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当饮用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。\n\n可达性分析算法通过树来保存对象的引用链，如果对象和根（GC Roots）不再有引用链时，就被判断判断为不可达。此时对象不会被立即回收，而是要经历一个 finalize() 方法的回收过程，在此过程中对象可以自救。\n\n\n### 垃圾收集算法\n#### 标记-清除算法\n最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n#### 复制算法\n为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。\n\n#### 标记-整理算法\n复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。\n\n根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n#### 分代收集算法\n当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。\n\n--------------------------\n参考资料：《深入理解Java虚拟机：JVM高级特性与最佳实践》","tags":["java"]},{"title":"通过例子理解mysql事务的4种隔离级别","url":"/posts/1528164495/","content":"SQL标准定义了4种隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。\n\n低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。\n\n首先，我们使用 test 数据库，新建 tx 表。\n\n### 第1级别：Read Uncommitted(读取未提交内容)\n(1)所有事务都可以看到其他未提交事务的执行结果  \n(2)本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少  \n(3)该级别引发的问题是——脏读(**Dirty Read**)：读取到了未提交的数据\n```\n#首先，修改隔离级别\nset tx_isolation='READ-UNCOMMITTED';\nselect @@tx_isolation;\n+------------------+\n| @@tx_isolation   |\n+------------------+\n| READ-UNCOMMITTED |\n+------------------+\n\n#事务A：启动一个事务\nstart transaction;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务B：也启动一个事务(那么两个事务交叉了)\n       在事务B中执行更新语句，且不提交\nstart transaction;\nupdate tx set num=10 where id=1;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务A：那么这时候事务A能看到这个更新了的数据吗?\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |   --->可以看到！说明我们读到了事务B还没有提交的数据\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务B：事务B回滚,仍然未提交\nrollback;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务A：在事务A里面看到的也是B没有提交的数据\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |      --->脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化，我都可以看到！\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n```\n-------------------------------------\n### 第2级别：Read Committed(读取提交内容)\n(1)这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）  \n(2)它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变  \n(3)这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。  \n|——>导致这种情况的原因可能有：\n1. 有一个交叉的事务有新的commit，导致了数据的改变  \n2. 一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit\n```\n#首先修改隔离级别\nset tx_isolation='read-committed';\nselect @@tx_isolation;\n+----------------+\n| @@tx_isolation |\n+----------------+\n| READ-COMMITTED |\n+----------------+\n\n#事务A：启动一个事务\nstart transaction;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务B：也启动一个事务(那么两个事务交叉了)\n       在这事务中更新数据，且未提交\nstart transaction;\nupdate tx set num=10 where id=1;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务A：这个时候我们在事务A中能看到数据的变化吗?\nselect * from tx; --------------->\n+------+------+                |\n| id   | num  |                |\n+------+------+                |\n|    1 |    1 |--->并不能看到！  |\n|    2 |    2 |                |\n|    3 |    3 |                |\n+------+------+                |——>相同的select语句，结果却不一样\n                               |\n#事务B：如果提交了事务B呢?         |\ncommit;                        |\n                               |\n#事务A:                         |\nselect * from tx; --------------->\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |--->因为事务B已经提交了，所以在A中我们看到了数据变化\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n```\n-------------------------------------\n### 第3级别：Repeatable Read(可重读)\n(1)这是MySQL的默认事务隔离级别  \n(2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行  \n(3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行  \n(4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题\n```\n#首先，更改隔离级别\nset tx_isolation='repeatable-read';\nselect @@tx_isolation;\n+-----------------+\n| @@tx_isolation  |\n+-----------------+\n| REPEATABLE-READ |\n+-----------------+\n\n#事务A：启动一个事务\nstart transaction;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务B：开启一个新事务(那么这两个事务交叉了)\n       在事务B中更新数据，并提交\nstart transaction;\nupdate tx set num=10 where id=1;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\ncommit;\n\n#事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |    1 | --->还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n\n#事务A：只有当事务A也提交了，它才能够看到数据变化\ncommit;\nselect * from tx;\n+------+------+\n| id   | num  |\n+------+------+\n|    1 |   10 |\n|    2 |    2 |\n|    3 |    3 |\n+------+------+\n```\n-------------------------------------\n### 第4级别：Serializable(可串行化)\n(1)这是最高的隔离级别  \n(2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。  \n(3)在这个级别，可能导致大量的超时现象和锁竞争\n```\n#首先修改隔离界别\nset tx_isolation='serializable';\nselect @@tx_isolation;\n+----------------+\n| @@tx_isolation |\n+----------------+\n| SERIALIZABLE   |\n+----------------+\n\n#事务A：开启一个新事务\nstart transaction;\n\n#事务B：在A没有commit之前，这个交叉事务是不能更改数据的\nstart transaction;\ninsert tx values('4','4');\nERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction\nupdate tx set num=10 where id=1;\nERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction\n```\n-------------------------------------\n| 隔离级别                      | 脏读 | 不可重复读 | 幻读 |\n| - | :-: | :-: | :-: |\n| 读未提交 ( Read uncommitted ) | ✓ | ✓ | ✓ |\n| 读已提交 ( Read committed )   | × | ✓ | ✓ |\n| 可重复读 ( Repeatable read )  | × | × | ✓ |\n| 可串行化 ( Serializable )     | × | × | × |\n\n参考文章\nhttp://xm-king.iteye.com/blog/770721\n\n转自：http://www.cnblogs.com/snsdzjlz320/p/5761387.html","tags":["mysql"]},{"title":"线上代码和rpc debug哪家强","url":"/posts/1528164505/","content":"标题两种情况，除了看日志外，还有一种做法是做一种转发器，把断点输出转发到程序员这边。这篇文章安利下我做的转发器 [rebugger](https://github.com/questionlin/rebugger)。\n\nrebugger 的原理是用 WorkerMan 做一个中转站，服务器通过 http 请求向中发出消息，中转站提取出内容，转发到程序员这边的 telnet \b客户端。例如 PHP 服务器，程序只要执行 file_get_contents() 就能把消息发出去了。\n\n使用 rebugger \b的优点是 file_get_contents() 一个函数就把消息发出去了，轻便无依赖。缺点是 get 请求不能有特殊字符，特殊情况需要转义一下。更重的做法是做一个插件，程序引入后可以有一个接口，直接发送 socket 请求给telnet 客户端。不过 rebugger 应该已经能满足大部分 php 程序员的需求了。","tags":["安利"]},{"title":"select poll epoll 之间的区别","url":"/posts/1528164527/","content":"select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。**但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。\n\n今天对这三种IO多路复用进行对比，参考网上和书上面的资料，整理如下：\n\n### 1. select 实现\nselect 的调用过程如下所示：  \n![过程图](http://wx4.sinaimg.cn/large/726f09bbgy1frycff5ubgj20hk0a8q34.jpg)\n1. 使用 copy_from_user 从用户控件拷贝 fd_set 到内核空间\n2. 注册回调函数 __pollwait\n3. 遍历所有 fd，调用其对应的 poll 方法（对于 socket， 这个 poll 方法是 sock_poll， sock_poll \b根据情况会调用到 tcp_poll, udp_poll 或者 datagram_poll)\n4. 以 tcp_poll 为例，其核心时间就是 __pollwait，也就是上面注册的回调函数。\n5. __pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk->sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。\n6. poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。\n7. 如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。\n8. 把fd_set从内核空间拷贝到用户空间。\n\n### 总结\nselect的几大缺点：\n\n（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大\n\n（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大\n\n（3）select支持的文件描述符数量太小了，默认是1024\n\n（4）你不能在等待的时候修改描述符集\n\n### 2. poll 实现\npoll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，没有大小限制，其他的都差不多。\n\n关于select和poll的实现分析，可以参考下面几篇博文：\n\nhttp://blog.csdn.net/lizhiguo0532/article/details/6568964#comments\n\nhttp://blog.csdn.net/lizhiguo0532/article/details/6568968\n\nhttp://blog.csdn.net/lizhiguo0532/article/details/6568969\n\nhttp://www.ibm.com/developerworks/cn/linux/l-cn-edntwk/index.html?ca=drs-\n\nhttp://linux.chinaunix.net/techdoc/net/2009/05/03/1109887.shtml\n\n### 3. epoll\nepoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。\n\n对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。\n\n对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。\n\n对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。\n\n### 总结：\n\n（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。\n\n（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。\n\n（3）即使一个线程处在 epoll_wait \b函数中，你也可以随时修改列表。\b\n\n（4）可以通过 epoll_wait() 使多个线程在同一个 epoll 队列中等待，这是 select / poll 无法做到的。\n\n### libevent\nlibevent 是一个库，将以上的方法封装在一套 API 中，使得\b同一套代码可以在不同系统中使用（\bFreeBSD 使用 kqueue)。\n\n参考资料：\n**https://www.cnblogs.com/Anker/p/3265058.html**\n\n**https://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/**\n\nhttp://www.cnblogs.com/apprentice89/archive/2013/05/09/3070051.html\n\nhttp://www.linuxidc.com/Linux/2012-05/59873p3.htm\n\nhttp://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/\n\nhttp://blog.csdn.net/kkxgx/article/details/7717125\n\nhttps://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/epoll-example.c\n\n三种方式的用法：\n\nselect: http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html\n\npoll: http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html\n\nepoll: http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html\n"},{"title":"mysql配置主从分离","url":"/posts/1528164516/","content":"原理：主服务器（Master）负责网站NonQuery操作，从服务器负责Query操作，用户可以根据网站功能模特性块固定访问Slave服务器，或者自己写个池或队列，自由为请求分配从服务器连接。主从服务器利用MySQL的二进制日志文件，实现数据同步。二进制日志由主服务器产生，从服务器响应获取同步数据库。\n\n具体实现：\n1. 配置 Master 主服务器\n    1. 在 Master MySQL 上创建用户'repl'，并允许其他 Slave 服务可以通过远程访问 Master，通过该用户读取二进制日志，\b实现数据同步。\n\n    ```\n    1 mysql>create user repl; //创建新用户\n    2 //repl用户必须具有REPLICATION SLAVE权限，除此之外没有必要添加不必要的权限，密码为mysql。说明一下192.168.0.%，这个配置是指明repl用户所在服务器，这里%是通配符，表示192.168.0.0-192.168.0.255的Server都可以以repl用户登陆主服务器。当然你也可以指定固定Ip。\n    3 mysql> GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.0.%' IDENTIFIED BY 'mysql';\n    ```\n\n    2. 找到MySQL安装文件夹修改my.Ini文件。mysql中有好几种日志方式，这不是今天的重点。我们只要启动二进制日志log-bin就ok。\n    在[mysqld]下面增加下面几行代码\n\n    ```\n    1 server-id=1   //给数据库服务的唯一标识，一般为大家设置服务器Ip的末尾号\n    2 log-bin=master-bin\n    3 log-bin-index=master-bin.index\n    ```\n\n    3. 查看日志\n    ```\n    mysql> SHOW MASTER STATUS;\n    +-------------------+----------+--------------+------------------+\n    | File | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n    +-------------------+----------+--------------+------------------+\n    | master-bin.000001 | 1285 | | |\n    +-------------------+----------+--------------+------------------+\n    1 row in set (0.00 sec)\n    ```\n    重启 MySQL 服务\n\n2. \b配置 Slave 从服务器 (windows)\n    1. 找到MySQL安装文件夹修改my.ini文件，在[mysqld]下面增加下面几行代码\n    ```\n    1 [mysqld]\n    2 server-id=2\n    3 relay-log-index=slave-relay-bin.index\n    4 relay-log=slave-relay-bin \n    ```\n    重启 MySQL 服务\n\n    2. 连接 Master\n    ```\n    change master to master_host='192.168.0.104', //Master 服务器Ip\n    master_port=3306,\n    master_user='repl',\n    master_password='mysql', \n    master_log_file='master-bin.000001',//Master服务器产生的日志\n    master_log_pos=0;\n    ```\n\n    3. 启动 Slave\n    ```\n    start slave;\n    ```\n\n3. Slave 从服务器 (Ubuntu)\n    1. 找到 MySQL 安装文件夹修改 my.cnf 文件， vim my.cnf\n    ```\n    [mysqld]\n    basedir =/usr/local/mysql\n    datadir =/usr/local/mysql/data\n    port = 3306\n    server_id = 3\n    relay_log_index=slave-relay-bin.index\n    relay_log=slave-relay-bin\n    ```\n\n    2. ./support-files/myql.server restart 重启MySQL服务  ,  ./bin/mysql 进入MySQL命令窗口 \n\n    3. 连接 Master\n    ```\n    change master to master_host='192.168.0.104', //Master 服务器Ip\n    master_port=3306,\n    master_user='repl',\n    master_password='mysql', \n    master_log_file='master-bin.000001',//Master服务器产生的日志\n    master_log_pos=0;\n    ```\n\n    4. 启动 Slave\n    ```\n    start slave;\n    ```\n\n转自：http://www.cnblogs.com/alvin_xp/p/4162249.html","tags":["架构"]},{"title":"最佳安全实践","url":"/posts/1528164481/","content":"对于需要自行或外包开发信息系统的商户来说，有一些安全的注意事项，我们从 需求、设计、编码、测试、部署&运维 五个方面来展开。  \n1. 需求  \n     a、商户自建营销活动需设计防刷机制。  \n2. 设计  \n     a、数据采集  \n◆ 法律禁止企业记录和存储的数据（如磁道信息、信用卡CVV码等）不能收集。  \n◆ 客户端敏感数据必须先进行加密处理。  \n     b、数据传输  \n◆ 使用HTTPS确保网络传输安全性。  \n◆ 禁用SSL等不安全协议和算法，建议使用TLS1.2。  \n◆ 不要轻易的尝试设计和实现自己的加密传输算法，几乎都会存在问题。  \n     c、数据保存  \n◆ 敏感信息禁止出现在日志中，如确实需要，需进行脱敏处理。  \n◆ 缓存和DB中的敏感数据需进行加密或者虚化（Hash）。  \n◆ 密码等关键认证必须采用加盐Hash方式保存。  \n     d、数据访问  \n◆ 外部请求数据访问必须进行鉴权操作。  \n◆ 对于内部的数据访问要严加控制，降低用户信息泄漏风险。  \n     e、审计日志  \n◆ 记录的操作日志要包括5W信息（Who、When、Why、How、What）。  \n     f、资金处理  \n◆ 建立对账机制，每天对系统收支数据与微信支付数据进行对账，避免资金出现问题。  \n◆ DB或者KV需要设计数据防篡改机制。  \n3. 编码  \n     a、防止参数处理不当导致的常见漏洞  \n◆ 参考 [Web漏洞检测及修复](http://wiki.open.qq.com/wiki/Web漏洞检测及修复)  \n     b、防止逻辑处理不当导致的漏洞  \n◆ 支付成功回调通知必须验证微信支付签名，避免被恶意攻击。  \n◆ 在后台进行商户价格的判断逻辑，避免客户端篡改价格导致商户损失。  \n◆ 避免在App或者网站页面里面出现商户APIkey或API证书等信息，防止泄漏。  \n     c、APP开发安全注意事项  \n◆ IOS应用安全开发参考 [Apple NextPrevious Security Development Checklists](https://developer.apple.com/library/content/documentation/Security/Conceptual/SecureCodingGuide/SecurityDevelopmentChecklists/SecurityDevelopmentChecklists.html)  \n◆ andriod应用安全开发参考 [Andriod Security Tips](https://developer.android.com/training/articles/security-tips.html)\n4. 测试  \n     a、对输入输出参数进行专项安全测试。  \n     b、通过众测或自建、第三方的安全扫描机制对系统进行安全扫描并对问题进行修复。\n5. 部署&运维\n     a、确保系统所使用商业和开源组件的版本是最新稳定版。  \n     b、参考此份checklist进行安全配置 [系统漏洞检测及修复](http://wiki.open.qq.com/wiki/系统漏洞检测及修复)  \n     c、考虑系统和数据服务容灾，至少有主备机制，建议多机房多地部署。  \n     d、建议采用各大云系统，并且启用相关的云安全防控机制。  \n     e、如有条件，建议自建或者购买一些安全监控服务或设备。  \n     f、设定关键指标项，进行实时数据上报和监控  \n     g、有专门的人员来跟进安全事件的处置。  \n     h、关注信息系统所使用框架及组件的安全信息情况。  \n     i、按时打补丁，定期检查系统升级。  \n     j、服务端口开启最小化原则。  \n     k、服务器登录操作可审计。  \n     m、内部管理运营系统必须认证登录做操作日志记录以供审计。  \n     n、建立业务下线机制，不再使用的业务做下线操作减少被攻击面。  \n\n\n转自 https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=23_3#menu1","tags":["安全"]},{"title":"HTTPS服务器配置","url":"/posts/1528164470/","content":"### 一、SSL证书申请\n\n1、确认需要申请证书的域名\n\n2、生成私钥和csr文件  \n在linux机器上执行以下命令生成私钥  \n```\n#openssl genrsa -out server.key 2048  \n```\n在linux机器上执行以下命令生成csr文件  \n```\n#openssl req -new -key server.key -out certreq.csr  \n```\n**以下黑色标识文字仅供参考，请根据商户自己实际情况进行填写**  \nCountry Name： **CN**                      //您所在国家的ISO标准代号，中国为CN  \nState or Province Name：**guandong**       //您单位所在地省/自治区/直辖市  \nLocality Name：**shenzhen**                 //您单位所在地的市/县/区  \nOrganization Name： **Tencent Technology (Shenzhen) Company Limited**                 //您单位/机构/企业合法的名称  \nOrganizational Unit Name： **R&D**         //部门名称  \nCommon Name： **www.example.com**     //通用名，例如：www.itrus.com.cn。此项必须与您访问提供SSL服务的服务器时所应用的域名完全匹配。  \nEmail Address：                          //您的邮件地址，不必输入，直接回车跳过  \n\"extra\"attributes                        //以下信息不必输入，回车跳过直到命令执行完毕。  \n执行上面的命令后，在当前目录下即可生成私钥文件**server.key**和**certreq.csr** csr文件\n\n3、将生成的csr文件提交给第三方证书颁发机构申请对应域名的服务器证书，同时将私钥文件保存好，以免丢失。\n\n4、证书申请后，证书颁发机构会提供服务器证书内容和两张中级CA证书，请按证书颁发机器说明生成服务器证书，此处假设服务器证书文件名称为**server.pem**\n\n5、将生成的私钥文件**server.key**和服务器证书**server.pem**拷贝至服务器指定的目录即可进行HTTPS服务器配置\n\n### 二、HTTPS服务器配置\n\n1、 Nginx配置\n```\nserver {\nlisten       443;   #指定ssl监听端口\nserver_name  www.example.com;\nssl on;    #开启ssl支持\nssl_certificate      /etc/nginx/server.pem;    #指定服务器证书路径\nssl_certificate_key  /etc/nginx/server.key;    #指定私钥证书路径\nssl_session_timeout  5m;\nssl_protocols TLSv1 TLSv1.1 TLSv1.2;     #指定SSL服务器端支持的协议版本\nssl_ciphers  ALL：!ADH：!EXPORT56：RC4+RSA：+HIGH：+MEDIUM：+LOW：+SSLv2：+EXP;    #指定加密算法\nssl_prefer_server_ciphers   on;    #在使用SSLv3和TLS协议时指定服务器的加密算法要优先于客户端的加密算法\n#以下内容请按域名需要进行配置，此处仅供参考\nlocation / {\nreturn 444;\n}\n}\n```\n2、其它web服务器配置\n请参考文档：http://www.itrus.cn/html/fuwuyuzhichi/fuwuqizhengshuanzhuangpeizhizhinan 《服务器证书配置指南》\n\n三、相关事项\n\n1、证书颁发机构  \n推荐天威诚信，具体请见：http://www.itrus.com.cn\n\n2、 参考文档  \nhttp://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_prefer_server_ciphers 《ngx_http_ssl_module》\nhttp://nginx.org/cn/docs/http/configuring_https_servers.html 《nginx配置HTTPS服务器》\nhttp://www.itrus.cn/html/fuwuyuzhichi/fuwuqizhengshuanzhuangpeizhizhinan 《服务器证书配置指南》\n\n3、常见问题  \n（1）证书受信任的问题  \n部分国内签发的SSL证书，在Android上不受信任，推荐GeoTrust；  \n（2）如果页面有动静分离，静态资源使用独立域名的话，也需要为该域名申请证书；  \n（3）android低版本不支持SNI扩展，受此限制，一台服务器只能部署一个数字证书；\n\n\n转自 https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=10_4","tags":["最佳实践"]},{"title":"阻止网页操作完成后自动跳转","url":"/posts/1528164457/","content":"阻止跳转的代码：\n\n$(window).on('beforeunload', () => { console.log('leave'); return false; });\n\nwindow.addEventListener('beforeunload', function(){console.log('leave');return false;});\n\n参考来源：https://jingyan.baidu.com/article/574c52190bc5ac6c8d9dc196.html","tags":["javascript"]},{"title":"打包网页完整内容的一个方法","url":"/posts/1528164446/","content":"用 safari 保存网站为归档，格式为 webarchive ，用 WebArchive Extractor 解压缩。\n\n这样不但能保存完整的 html, javascript, css，而且\b每个文件分开，非常直观。"},{"title":"redis主从切换踩坑","url":"/posts/1528164430/","content":"昨天配置了 redis sentinel 的主从切换，无论如何都无法成功，网上也都不到原因。\n\n后来观察 sentinel 是正常工作的，可是服务器之间只传递 sdown 没有传递 odown，于是用这个搜到了。原来 sentinel 有 protected mode，要在配置里添加 bind 0.0.0.0。改完了之后终于切换成功了。\n\n这个东西弄了我有10小时吧，配置模版里提都没提，真是大坑。","tags":["redis"]},{"title":"用人话教你设计模式","url":"/posts/1528164421/","content":"![Design Patterns For Humans](https://cloud.githubusercontent.com/assets/11269635/23065273/1b7e5938-f515-11e6-8dd3-d0d58de6bb9a.png)\n\n***\n<p align=\"center\">\n🎉 对设计模式的极简说明！🎉\n</p>\n<p align=\"center\">\n这个话题可以轻易让任何人糊涂。现在我尝试通过用<i>最简单</i>的方式说明它们，来让你（和我）把他们吃透。\n</p>\n***\n\n🚀 简介\n=================\n\n设计模式用来解决重复的问题；**是解决特定问题的指导方针**。它们不是类(class)，包(packages)，或者库(libraries)，你不能引入它们，然后等待奇迹发生。它们是针对解决特定环境下特定问题的指导方针。\n\n> 设计模式用来解决重复的问题；是解决特定问题的指导方针\n\n维基百科的解释\n\n> In software engineering, a software design pattern is a general reusable solution to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. It is a description or template for how to solve a problem that can be used in many different situations.\n\n⚠️ 请注意\n-----------------\n- 设计模式不是解决你所有问题的银弹。\n- 不要尝试强行使用它们；如果做了，不好的事情可能发生。请记住设计模式是**解决**问题的方案，不是**发现**问题；所以不要过度思考。\n- 如果在正确的地方以正确的方式使用，它们被证明是有帮助的；否则结果可能是一堆可怕混乱的代码。\n\n> 下面的代码示例使用 PHP-7 书写，但你不应止步于此，因为理念是相通的。再加上,**对其他语言的支持正在路上**。\n\n设计模式的种类\n-----------------\n\n* [创建型](#创建型模式)\n* [结构型](#结构型模式)\n* [行为型](#行为型模式)\n\n创建型模式\n==========================\n\n白话\n> 创建型模式侧重如何实例化一个对象或一组相关对象。\n\n维基百科\n> In software engineering, creational design patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.\n \n * [简单工厂模式 Simple Factory](#-简单工厂模式)\n * [工厂方法模式 Factory Method](#-工厂方法模式)\n * [抽象工厂模式 Abstract Factory](#-抽象工厂模式)\n * [建造者模式 Builder](#-建造者模式)\n * [原型模式 Prototype](#-原型模式)\n * [单例模式 Singleton](#-单例模式)\n \n🏠 简单工厂模式\n--------------\n现实例子\n> 假设，你正在建造一所房子，你需要门。如果每次你需要一扇门你都要穿上木工服开始在房子里造扇门，将会是一团乱。取而代之的是让工厂造好。\n\n白话\n> 简单工厂模式在不暴露生成逻辑的前提下生成一个实例。\n\n维基百科\n> In object-oriented programming (OOP), a factory is an object for creating other objects – formally a factory is a function or method that returns objects of a varying prototype or class from some method call, which is assumed to be \"new\".\n\n**代码例子**\n\n首先，我们有一个门的接口和实现\n```php\ninterface Door {\n    public function getWidth() : float;\n    public function getHeight() : float;\n}\n\nclass WoodenDoor implements Door {\n    protected $width;\n    protected $height;\n\n    public function __construct(float $width, float $height) {\n        $this->width = $width;\n        $this->height = $height;\n    }\n    \n    public function getWidth() : float {\n        return $this->width;\n    }\n    \n    public function getHeight() : float {\n        return $this->height;\n    }\n}\n```\n然后，我们有了工厂来制造和返回门\n```php\nclass DoorFactory {\n   public static function makeDoor($width, $height) : Door {\n       return new WoodenDoor($width, $height);\n   }\n}\n```\n然后这样使用\n```php\n$door = DoorFactory::makeDoor(100, 200);\necho 'Width: ' . $door->getWidth();\necho 'Height: ' . $door->getHeight();\n```\n\n**什么时候使用？**\n\n当创建一个对象不只是几个赋值和逻辑计算，把这件工作交给一个工厂而不是到处重复相同的代码就比较合适了。\n\n🏭 工厂方法模式\n--------------\n\n现实例子\n> 设想一个人事经理。一个人是不可能面试所有职位的。基于职位空缺，她必须把面试委托给不同的人。\n\n白话\n> 它提供了一个把生成逻辑移交给子类的方法。\n\n维基百科\n> In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object that will be created. This is done by creating objects by calling a factory method—either specified in an interface and implemented by child classes, or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor.\n \n **代码例子**\n \n以上面的人事经理为例。首先我们有一个面试官接口和一些实现\n\n```php\ninterface Interviewer {\n    public function askQuestions();\n}\n\nclass Developer implements Interviewer {\n    public function askQuestions() {\n        echo 'Asking about design patterns!';\n    }\n}\n\nclass CommunityExecutive implements Interviewer {\n    public function askQuestions() {\n        echo 'Asking about community building';\n    }\n}\n```\n\n现在我们新建我们的人事经理 `HiringManager`\n\n```php\nabstract class HiringManager {\n    \n    // Factory method\n    abstract public function makeInterviewer() : Interviewer;\n    \n    public function takeInterview() {\n        $interviewer = $this->makeInterviewer();\n        $interviewer->askQuestions();\n    }\n}\n```\n现在任何一个都可以继承它，并且生成需要的面试官\n```php\nclass DevelopmentManager extends HiringManager {\n    public function makeInterviewer() : Interviewer {\n        return new Developer();\n    }\n}\n\nclass MarketingManager extends HiringManager {\n    public function makeInterviewer() : Interviewer {\n        return new CommunityExecutive();\n    }\n}\n```\n然后可以这样使用\n\n```php\n$devManager = new DevelopmentManager();\n$devManager->takeInterview(); // Output: Asking about design patterns\n\n$marketingManager = new MarketingManager();\n$marketingManager->takeInterview(); // Output: Asking about community building.\n```\n\n**何时使用？**\n\n当一个类里有普遍性的处理过程，但是子类要在运行时才确定。或者换句话说，调用者不知道它需要哪个子类。\n\n🔨 抽象工厂模式\n----------------\n\n现实例子\n> 扩展我们简单工厂模式的例子。基于你的需求，你可以从木门店得到一扇木门，从铁门店得到一扇铁门，或者从塑料门店得到一扇塑料门。而且你需要一个有不同专长的人来安装这扇门，比如一个木匠来安木门，焊工来安铁门等。正如你看的，门和安装工有依赖性，木门需要木匠，铁门需要焊工等。\n\n白话\n> 一个制造工厂的工厂；一个工厂把独立但是相关／有依赖性的工厂进行分类，但是不需要给出具体的类。\n  \n维基百科\n> The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes\n\n**代码例子**\n\n翻译上面门的例子。首先我们有了门 `Door` 的接口和一些实现\n\n```php\ninterface Door {\n    public function getDescription();\n}\n\nclass WoodenDoor implements Door {\n    public function getDescription() {\n        echo 'I am a wooden door';\n    }\n}\n\nclass IronDoor implements Door {\n    public function getDescription() {\n        echo 'I am an iron door';\n    }\n}\n```\n然后我们有了每种门的安装专家\n\n```php\ninterface DoorFittingExpert {\n    public function getDescription();\n}\n\nclass Welder implements DoorFittingExpert {\n    public function getDescription() {\n        echo 'I can only fit iron doors';\n    }\n}\n\nclass Carpenter implements DoorFittingExpert {\n    public function getDescription() {\n        echo 'I can only fit wooden doors';\n    }\n}\n```\n\n现在我们有了抽象工厂来创建全部相关的对象，即木门工厂制造木门和木门安装专家，铁门工厂制造铁门和铁门安装专家\n```php\ninterface DoorFactory {\n    public function makeDoor() : Door;\n    public function makeFittingExpert() : DoorFittingExpert;\n}\n\n// 木头工厂返回木门和木匠\nclass WoodenDoorFactory implements DoorFactory {\n    public function makeDoor() : Door {\n        return new WoodenDoor();\n    }\n\n    public function makeFittingExpert() : DoorFittingExpert{\n        return new Carpenter();\n    }\n}\n\n// 铁门工厂返回铁门和对应安装专家\nclass IronDoorFactory implements DoorFactory {\n    public function makeDoor() : Door {\n        return new IronDoor();\n    }\n\n    public function makeFittingExpert() : DoorFittingExpert{\n        return new Welder();\n    }\n}\n```\n然后可以这样使用\n```php\n$woodenFactory = new WoodenDoorFactory();\n\n$door = $woodenFactory->makeDoor();\n$expert = $woodenFactory->makeFittingExpert();\n\n$door->getDescription();  // 输出: I am a wooden door\n$expert->getDescription(); // 输出: I can only fit wooden doors\n\n// 铁门工厂也一样\n$ironFactory = new IronDoorFactory();\n\n$door = $ironFactory->makeDoor();\n$expert = $ironFactory->makeFittingExpert();\n\n$door->getDescription();  // 输出: I am an iron door\n$expert->getDescription(); // 输出: I can only fit iron doors\n```\n\n如你所见，木门工厂包含了木匠 `carpenter` 和木门 `wooden door` 而铁门工厂包含了铁门 `iron door` 和焊工 `welder`。因此我们可以确保每扇制造出来的门不会带上错误的安装工。\n\n**何时使用？**\n\n当创建逻辑不那么简单，而且相互之间有依赖时\n\n👷 建造者模式\n--------------------------------------------\n现实例子\n> 想象你在麦当劳，你要一个“巨无霸”，他们马上就给你了，没有疑问，这是简单工厂的逻辑。但如果创建逻辑包含更多步骤。比如你想要一个自定义赛百味套餐，你有多种选择来制作汉堡，例如你要哪种面包？你要哪种调味酱？你要哪种奶酪？等。这种情况就需要建造者模式来处理。\n\n白话\n> 让你能创建不同特点的对象而避免构造函数污染。当一个对象都多种特点的时候比较实用。或者在创造逻辑里有许多步骤的时候。\n \n维基百科\n> The builder pattern is an object creation software design pattern with the intentions of finding a solution to the telescoping constructor anti-pattern.\n\n话虽如此，让我写一点关于伸缩构造函数反面模式。在某些时候，我们都看过下面这样的构造函数\n \n```php\npublic function __construct($size, $cheese = true, $pepperoni = true, $tomato = false, $lettuce = true) {\n}\n```\n\n如你所见；构造函数参数的数量马上就要失去控制，而且梳理参数也会变得困难。而且如果你将来想要增加更多选项，参数也会继续增加。这就叫做伸缩构造函数反面模式。\n\n**代码例子**\n\n正常的做法是使用创建者模式。首先我们有了要做的汉堡\n\n```php\nclass Burger {\n    protected $size;\n\n    protected $cheese = false;\n    protected $pepperoni = false;\n    protected $lettuce = false;\n    protected $tomato = false;\n    \n    public function __construct(BurgerBuilder $builder) {\n        $this->size = $builder->size;\n        $this->cheese = $builder->cheese;\n        $this->pepperoni = $builder->pepperoni;\n        $this->lettuce = $builder->lettuce;\n        $this->tomato = $builder->tomato;\n    }\n}\n```\n\n然后我们有了制作者\n\n```php\nclass BurgerBuilder {\n    public $size;\n\n    public $cheese = false;\n    public $pepperoni = false;\n    public $lettuce = false;\n    public $tomato = false;\n\n    public function __construct(int $size) {\n        $this->size = $size;\n    }\n    \n    public function addPepperoni() {\n        $this->pepperoni = true;\n        return $this;\n    }\n    \n    public function addLettuce() {\n        $this->lettuce = true;\n        return $this;\n    }\n    \n    public function addCheese() {\n        $this->cheese = true;\n        return $this;\n    }\n    \n    public function addTomato() {\n        $this->tomato = true;\n        return $this;\n    }\n    \n    public function build() : Burger {\n        return new Burger($this);\n    }\n}\n```\n然后可以这样使用\n\n```php\n$burger = (new BurgerBuilder(14))\n                    ->addPepperoni()\n                    ->addLettuce()\n                    ->addTomato()\n                    ->build();\n```\n\n**何时使用？**\n\n当对象有多种特性而要避免构造函数变长。和工厂模式的核心区别是；当创建过程只有一个步骤的时候使用工厂模式，而当创建过程有多个步骤的时候使用创造者模式。\n\n🐑 原型模式\n------------\n现实例子\n> 记得多利吗？那只克隆羊！不要在意细节，现在的重点是克隆\n\n白话\n> 通过克隆已有的对象来创建新对象。\n\n维基百科\n> The prototype pattern is a creational design pattern in software development. It is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects.\n\n长话短说，它让你创建已有对象的拷贝，然后修改到你要的样子，而不是从头开始建造。\n\n**代码例子**\n\n在 PHP 里，简单的使用 `clone` 就可以了\n  \n```php\nclass Sheep {\n    protected $name;\n    protected $category;\n\n    public function __construct(string $name, string $category = 'Mountain Sheep') {\n        $this->name = $name;\n        $this->category = $category;\n    }\n    \n    public function setName(string $name) {\n        $this->name = $name;\n    }\n\n    public function getName() {\n        return $this->name;\n    }\n\n    public function setCategory(string $category) {\n        $this->category = $category;\n    }\n\n    public function getCategory() {\n        return $this->category;\n    }\n}\n```\n然后它可以被这样克隆\n```php\n$original = new Sheep('Jolly');\necho $original->getName(); // Jolly\necho $original->getCategory(); // Mountain Sheep\n\n// Clone and modify what is required\n$cloned = clone $original;\n$cloned->setName('Dolly');\necho $cloned->getName(); // Dolly\necho $cloned->getCategory(); // Mountain sheep\n```\n\n你也可以使用魔法方法 `__clone` 来改变克隆逻辑。\n\n**何时使用？**\n\n当一个对象需要跟已有的对象相似，或者当创造过程比起克隆来太昂贵时。\n\n💍 单例模式\n------------\n现实例子\n> 一个国家同一时间只能有一个总统。当使命召唤的时候，这个总统要采取行动。这里的总统就是单例的。\n\n白话\n> 确保指定的类只生成一个对象。\n\n维基百科\n> In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system.\n\n单例模式其实被看作一种反面模式，应该避免过度使用。它不一定不好，而且确有一些有效的用例，但是应该谨慎使用，因为它在你的应用里引入了全局状态，在一个地方改变，会影响其他地方。而且很难 debug 。另一个坏处是它让你的代码紧耦合，而且很难仿制单例。\n\n**代码例子**\n\n要创建一个单例，先让构造函数私有，不能克隆，不能继承，然后创造一个静态变量来保存这个实例\n```php\nfinal class President {\n    private static $instance;\n\n    private function __construct() {\n        // Hide the constructor\n    }\n    \n    public static function getInstance() : President {\n        if (!self::$instance) {\n            self::$instance = new self();\n        }\n        \n        return self::$instance;\n    }\n    \n    private function __clone() {\n        // Disable cloning\n    }\n    \n    private function __wakeup() {\n        // Disable unserialize\n    }\n}\n```\n然后要使用的话\n```php\n$president1 = President::getInstance();\n$president2 = President::getInstance();\n\nvar_dump($president1 === $president2); // true\n```\n\n结构型模式\n==========================\n白话\n> 结构型模式更关注对象的组合，换句话说，实体如何彼此使用。或者说，它们帮助解答“如何建造软件组件？”\n\n维基百科\n> In software engineering, structural design patterns are design patterns that ease the design by identifying a simple way to realize relationships between entities.\n  \n * [适配器模式 Adapter](#-适配器模式)\n * [桥接模式 Bridge](#-桥接模式)\n * [组合模式 Composite](#-组合模式)\n * [装饰器模式 Decorator](#-装饰器模式)\n * [门面模式 Facade](#-门面模式)\n * [享元模式 Flyweight](#-享元模式)\n * [代理模式 Proxy](#-代理模式)\n\n🔌 适配器模式\n-------\n现实例子\n> 假设在你的存储卡里有一些照片，你要把它们传到电脑。为了传输，你需要一个兼容电脑端口的适配器来连接存储卡和电脑。在这里，读卡器就是一个适配器。\n> 另一个例子是电源转换器；一个三脚的插口不能插到两口的插座上，它需要一个电源转换器来兼容两口的插座。\n> 还有一个例子是翻译将一个人说的话翻译给另一个人。\n\n白话\n> 适配器模式让你封装一个不兼容的对象到一个适配器，来兼容其他类。\n\n维基百科\n> In software engineering, the adapter pattern is a software design pattern that allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code.\n\n**代码例子**\n\n假设一个猎人狩猎狮子的游戏。\n\n首先我们有了一个接口狮子 `Lion` 来实现所有种类的狮子\n\n```php\ninterface Lion {\n    public function roar();\n}\n\nclass AfricanLion implements Lion {\n    public function roar() {}\n}\n\nclass AsianLion implements Lion {\n    public function roar() {}\n}\n```\n以及猎人需要狩猎任何狮子 `Lion` 接口的实现。\n```php\nclass Hunter {\n    public function hunt(Lion $lion) {\n    }\n}\n```\n\n现在我们不得不在游戏里加一个野狗 `WildDog` ，猎人也能狩猎它。但是我们不能直接这么做，因为狗有不同的接口。为了兼容我们的猎人，我们不得不创建一个兼容的适配器\n \n```php\n// This needs to be added to the game\nclass WildDog {\n    public function bark() {}\n}\n\n// Adapter around wild dog to make it compatible with our game\nclass WildDogAdapter implements Lion {\n    protected $dog;\n\n    public function __construct(WildDog $dog) {\n        $this->dog = $dog;\n    }\n    \n    public function roar() {\n        $this->dog->bark();\n    }\n}\n```\n现在野狗 `WildDog` 可以在游戏里使用了，通过野狗适配器 `WildDogAdapter`.\n\n```php\n$wildDog = new WildDog();\n$wildDogAdapter = new WildDogAdapter($wildDog);\n\n$hunter = new Hunter();\n$hunter->hunt($wildDogAdapter);\n```\n\n🚡 桥接模式\n------\n现实例子\n> 假设你有一个包含很多网页的网站，你想要用户可以改变主题。你会怎么做？创建每个页面对应每个主题的拷备，还是只是创建不同的主题，然后根据用户的喜好来加载它们？桥接模式让你能做到后者。\n\n![With and without the bridge pattern](https://cloud.githubusercontent.com/assets/11269635/23065293/33b7aea0-f515-11e6-983f-98823c9845ee.png)\n\n白话\n> 桥接模式倾向构造而非继承。实现细节被从一个层推送到另一个对象的另一层。\n\n维基百科\n> The bridge pattern is a design pattern used in software engineering that is meant to \"decouple an abstraction from its implementation so that the two can vary independently\"\n\n**代码例子**\n\n翻译我们上面的网页例子。这里是网页 `WebPage` 层\n\n```php\ninterface WebPage {\n    public function __construct(Theme $theme);\n    public function getContent();\n}\n\nclass About implements WebPage {\n    protected $theme;\n    \n    public function __construct(Theme $theme) {\n        $this->theme = $theme;\n    }\n    \n    public function getContent() {\n        return \"About page in \" . $this->theme->getColor();\n    }\n}\n\nclass Careers implements WebPage {\n   protected $theme;\n   \n   public function __construct(Theme $theme) {\n       $this->theme = $theme;\n   }\n   \n   public function getContent() {\n       return \"Careers page in \" . $this->theme->getColor();\n   } \n}\n```\n以及主题层\n```php\ninterface Theme {\n    public function getColor();\n}\n\nclass DarkTheme implements Theme {\n    public function getColor() {\n        return 'Dark Black';\n    }\n}\nclass LightTheme implements Theme {\n    public function getColor() {\n        return 'Off white';\n    }\n}\nclass AquaTheme implements Theme {\n    public function getColor() {\n        return 'Light blue';\n    }\n}\n```\n两个层的互动\n```php\n$darkTheme = new DarkTheme();\n\n$about = new About($darkTheme);\n$careers = new Careers($darkTheme);\n\necho $about->getContent(); // \"About page in Dark Black\";\necho $careers->getContent(); // \"Careers page in Dark Black\";\n```\n\n🌿 组合模式\n-----------------\n\n现实例子\n> 任何组织都是由员工组成。每个员工都有相同的特征，即一笔薪水，一些责任，可能需要向别人汇报，可能有一些下属等。\n\n白话\n> 组合模式让调用者可以用统一的模式对待不同的对象。\n\n维基百科\n> In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes that a group of objects is to be treated in the same way as a single instance of an object. The intent of a composite is to \"compose\" objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.\n\n**代码例子**\n\n拿上面的员工为例。下面是不同的员工类型\n\n```php\n\ninterface Employee {\n    public function __construct(string $name, float $salary);\n    public function getName() : string;\n    public function setSalary(float $salary);\n    public function getSalary() : float;\n    public function getRoles()  : array;\n}\n\nclass Developer implements Employee {\n\n    protected $salary;\n    protected $name;\n\n    public function __construct(string $name, float $salary) {\n        $this->name = $name;\n        $this->salary = $salary;\n    }\n\n    public function getName() : string {\n        return $this->name;\n    }\n\n    public function setSalary(float $salary) {\n        $this->salary = $salary;\n    }\n\n    public function getSalary() : float {\n        return $this->salary;\n    }\n\n    public function getRoles() : array {\n        return $this->roles;\n    }\n}\n\nclass Designer implements Employee {\n\n    protected $salary;\n    protected $name;\n\n    public function __construct(string $name, float $salary) {\n        $this->name = $name;\n        $this->salary = $salary;\n    }\n\n    public function getName() : string {\n        return $this->name;\n    }\n\n    public function setSalary(float $salary) {\n        $this->salary = $salary;\n    }\n\n    public function getSalary() : float {\n        return $this->salary;\n    }\n\n    public function getRoles() : array {\n        return $this->roles;\n    }\n}\n```\n\n下面是一个由不同类型员工组成的组织\n\n```php\nclass Organization {\n    \n    protected $employees;\n\n    public function addEmployee(Employee $employee) {\n        $this->employees[] = $employee;\n    }\n\n    public function getNetSalaries() : float {\n        $netSalary = 0;\n\n        foreach ($this->employees as $employee) {\n            $netSalary += $employee->getSalary();\n        }\n\n        return $netSalary;\n    }\n}\n```\n\n然后可以这样使用\n\n```php\n// 准备员工\n$john = new Developer('John Doe', 12000);\n$jane = new Designer('Jane', 10000);\n\n// 把他们加到组织里去\n$organization = new Organization();\n$organization->addEmployee($john);\n$organization->addEmployee($jane);\n\necho \"Net salaries: \" . $organization->getNetSalaries(); // Net Salaries: 22000\n```\n\n☕ 装饰器模式\n-------------\n\n现实例子\n\n> 想象你开一家汽车服务店，提供各种服务。现在你怎么计算收费？你选择一个服务，然后不断把价格加到已选服务的价格里，直到得到总价。这里，每种服务就是一个装饰器。\n\n白话\n> 装饰器模式让你能在运行时动态地改变一个对象的表现，通过把它们封装到一个装饰器类。\n\n维基百科\n> In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern.\n\n**代码例子**\n\n让我们以咖啡为例。首先我们有一个咖啡接口的简单实现\n\n```php\ninterface Coffee {\n    public function getCost();\n    public function getDescription();\n}\n\nclass SimpleCoffee implements Coffee {\n\n    public function getCost() {\n        return 10;\n    }\n\n    public function getDescription() {\n        return 'Simple coffee';\n    }\n}\n```\n我们想要让代码可扩展，以在需要的时候改变选项。让我们增加一些扩展（装饰器）\n```php\nclass MilkCoffee implements Coffee {\n    \n    protected $coffee;\n\n    public function __construct(Coffee $coffee) {\n        $this->coffee = $coffee;\n    }\n\n    public function getCost() {\n        return $this->coffee->getCost() + 2;\n    }\n\n    public function getDescription() {\n        return $this->coffee->getDescription() . ', milk';\n    }\n}\n\nclass WhipCoffee implements Coffee {\n\n    protected $coffee;\n\n    public function __construct(Coffee $coffee) {\n        $this->coffee = $coffee;\n    }\n\n    public function getCost() {\n        return $this->coffee->getCost() + 5;\n    }\n\n    public function getDescription() {\n        return $this->coffee->getDescription() . ', whip';\n    }\n}\n\nclass VanillaCoffee implements Coffee {\n\n    protected $coffee;\n\n    public function __construct(Coffee $coffee) {\n        $this->coffee = $coffee;\n    }\n\n    public function getCost() {\n        return $this->coffee->getCost() + 3;\n    }\n\n    public function getDescription() {\n        return $this->coffee->getDescription() . ', vanilla';\n    }\n}\n\n```\n\n现在让我们生成咖啡\n\n```php\n$someCoffee = new SimpleCoffee();\necho $someCoffee->getCost(); // 10\necho $someCoffee->getDescription(); // Simple Coffee\n\n$someCoffee = new MilkCoffee($someCoffee);\necho $someCoffee->getCost(); // 12\necho $someCoffee->getDescription(); // Simple Coffee, milk\n\n$someCoffee = new WhipCoffee($someCoffee);\necho $someCoffee->getCost(); // 17\necho $someCoffee->getDescription(); // Simple Coffee, milk, whip\n\n$someCoffee = new VanillaCoffee($someCoffee);\necho $someCoffee->getCost(); // 20\necho $someCoffee->getDescription(); // Simple Coffee, milk, whip, vanilla\n```\n\n📦 门面模式\n----------------\n\n现实例子\n> 你怎么打开电脑？你会说“按电源键”！你这么认为是因为你在用电脑外部提供的简单接口，而在内部，它必须做很做工作来实现这件事。这个复杂子系统的简单接口就是一个门面。\n\n白话\n> 门面模式提供了一个复杂子系统的简单接口。\n\n维基百科\n> A facade is an object that provides a simplified interface to a larger body of code, such as a class library.\n\n**代码例子**\n\n拿上面电脑为例。下面是电脑类\n\n```php\nclass Computer {\n\n    public function getElectricShock() {\n        echo \"Ouch!\";\n    }\n\n    public function makeSound() {\n        echo \"Beep beep!\";\n    }\n\n    public function showLoadingScreen() {\n        echo \"Loading..\";\n    }\n\n    public function bam() {\n        echo \"Ready to be used!\";\n    }\n\n    public function closeEverything() {\n        echo \"Bup bup bup buzzzz!\";\n    }\n\n    public function sooth() {\n        echo \"Zzzzz\";\n    }\n\n    public function pullCurrent() {\n        echo \"Haaah!\";\n    }\n}\n```\n下面是门面\n```php\nclass ComputerFacade\n{\n    protected $computer;\n\n    public function __construct(Computer $computer) {\n        $this->computer = $computer;\n    }\n\n    public function turnOn() {\n        $this->computer->getElectricShock();\n        $this->computer->makeSound();\n        $this->computer->showLoadingScreen();\n        $this->computer->bam();\n    }\n\n    public function turnOff() {\n        $this->computer->closeEverything();\n        $this->computer->pullCurrent();\n        $this->computer->sooth();\n    }\n}\n```\n如何使用门面\n```php\n$computer = new ComputerFacade(new Computer());\n$computer->turnOn(); // Ouch! Beep beep! Loading.. Ready to be used!\n$computer->turnOff(); // Bup bup buzzz! Haah! Zzzzz\n```\n\n🍃 享元模式\n---------\n\n现实例子\n> 你在小店里喝过茶吗？他们经常比你要的多做几杯，把剩下的留给别的客人，以此来省资源，比如煤气。享元模式就是以上的体现，即分享。\n\n白话\n> 通过尽可能分享相似的对象，来将内存使用或计算开销降到最低。\n\n维基百科\n> In computer programming, flyweight is a software design pattern. A flyweight is an object that minimizes memory use by sharing as much data as possible with other similar objects; it is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory.\n\n**代码例子**\n\n翻译上面的茶的例子。首先我们有了茶的类型和生成器\n\n```php\n// 任何被缓存的东西都被叫做享元。 \n// 这里茶的类型就是享元。\nclass KarakTea {\n}\n\n// 像工厂一样工作，保存茶\nclass TeaMaker {\n    protected $availableTea = [];\n\n    public function make($preference) {\n        if (empty($this->availableTea[$preference])) {\n            $this->availableTea[$preference] = new KarakTea();\n        }\n\n        return $this->availableTea[$preference];\n    }\n}\n```\n\n下面是我们的茶吧 `TeaShop` ，接单和提供服务\n\n```php\nclass TeaShop {\n    \n    protected $orders;\n    protected $teaMaker;\n\n    public function __construct(TeaMaker $teaMaker) {\n        $this->teaMaker = $teaMaker;\n    }\n\n    public function takeOrder(string $teaType, int $table) {\n        $this->orders[$table] = $this->teaMaker->make($teaType);\n    }\n\n    public function serve() {\n        foreach($this->orders as $table => $tea) {\n            echo \"Serving tea to table# \" . $table;\n        }\n    }\n}\n```\n然后可以这样使用\n\n```php\n$teaMaker = new TeaMaker();\n$shop = new TeaShop($teaMaker);\n\n$shop->takeOrder('less sugar', 1);\n$shop->takeOrder('more milk', 2);\n$shop->takeOrder('without sugar', 5);\n\n$shop->serve();\n// Serving tea to table# 1\n// Serving tea to table# 2\n// Serving tea to table# 5\n```\n\n🎱 代理模式\n-------------------\n现实例子\n> 你有没有用过门卡来通过一扇门？有多种方式来打开那扇门，即它可以被门卡打开，或者按开门按钮打开。这扇门的主要功能是开关，但在顶层增加了一个代理来增加其他功能。下面的例子能更好的说明。\n\n白话\n> 使用代理模式，一个类表现出了另一个类的功能。\n\n维基百科\n> A proxy, in its most general form, is a class functioning as an interface to something else. A proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be forwarding to the real object, or can provide additional logic. In the proxy extra functionality can be provided, for example caching when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked.\n\n**代码例子**\n\n拿上面安全门为例。首先我们有了门的接口和实现\n\n```php\ninterface Door {\n    public function open();\n    public function close();\n}\n\nclass LabDoor implements Door {\n    public function open() {\n        echo \"Opening lab door\";\n    }\n\n    public function close() {\n        echo \"Closing the lab door\";\n    }\n}\n```\n然后下面是一个代理来安保任何我们要的门\n```php\nclass Security {\n    protected $door;\n\n    public function __construct(Door $door) {\n        $this->door = $door;\n    }\n\n    public function open($password) {\n        if ($this->authenticate($password)) {\n            $this->door->open();\n        } else {\n        \techo \"Big no! It ain't possible.\";\n        }\n    }\n\n    public function authenticate($password) {\n        return $password === '$ecr@t';\n    }\n\n    public function close() {\n        $this->door->close();\n    }\n}\n```\n然后可以这样使用\n```php\n$door = new Security(new LabDoor());\n$door->open('invalid'); // Big no! It ain't possible.\n\n$door->open('$ecr@t'); // Opening lab door\n$door->close(); // Closing lab door\n```\n另一个例子是一些数据映射的实现。比如，我最近用这个模式给 MongoDB 做了一个数据映射器 ODM (Object Data Mapper)，我用魔术方法 `__call()` 给 mongo 类做了一个代理。所有执行的方法都被代理到原始的 mongo 类，返回收到的结果。但是在 `find` 或 `findOne` 的情况，数据被映射到对应的对象，这个对象会被返回，而不是 `Cursor`。\n\n行为型模式\n==========================\n\n白话\n> 它关注对象间的责任分配。它们和结构型模式的区别是它们不止明确指明结构，而且指出了它们之间传递/交流的信息的形式。或者换句或说，它们帮助回答了“如何确定软件组件的行为？”\n\n维基百科\n> In software engineering, behavioral design patterns are design patterns that identify common communication patterns between objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication.\n\n* [责任链模式 Chain of Responsibility](#-责任链模式)\n* [命令模式 Command](#-命令模式)\n* [迭代器模式 Iterator](#-迭代器模式)\n* [中介模式 Mediator](#-中介模式)\n* [备忘录模式 Memento](#-备忘录模式)\n* [观察者模式 Observer](#-观察者模式)\n* [访问者模式 Visitor](#-访问者模式)\n* [策略模式 Strategy](#-策略模式)\n* [状态模式 State](#-状态模式)\n* [模板模式 Template Method](#-模板模式)\n\n🔗 责任链模式\n-----------------------\n\n现实例子\n> 比如，有三个支付方式 (`A`, `B` 和 `C`) 安装在你的账户里；每种方式都有不同额度。`A` 有 100 元， `B` 有 300 元，以及 `C` 有 1000 元，选择支付方式的顺序是 `A` 然后 `B` 然后 `C`。你要买一些价值 210 元的东西。使用责任链模式，首先账户 `A` 会被检查是否能够支付，如果是，支付会被执行而链子终止。如果否，请求会转移到账户 `B`，检查额度，如果是，链子终止，否则请求继续转移直到找到合适的执行者。这里 `A`，`B` 和 `C` 是链接里的环节，它们合起来就是责任链。\n\n白话\n> 它构造了一个对象的链。请求进入一端，然后从一个对象到另一个对象直到找到合适的执行者。\n\n维基百科\n> In object-oriented design, the chain-of-responsibility pattern is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain.\n\n**代码例子**\n\n翻译上面的账户例子。首先我们有了一个基本账户，包含把账户连接起来的逻辑。以及一些账户\n\n```php\nabstract class Account {\n    protected $successor;\n    protected $balance;\n\n    public function setNext(Account $account) {\n        $this->successor = $account;\n    }\n    \n    public function pay(float $amountToPay) {\n        if ($this->canPay($amountToPay)) {\n            echo sprintf('Paid %s using %s' . PHP_EOL, $amountToPay, get_called_class());\n        } else if ($this->successor) {\n            echo sprintf('Cannot pay using %s. Proceeding ..' . PHP_EOL, get_called_class());\n            $this->successor->pay($amountToPay);\n        } else {\n            throw Exception('None of the accounts have enough balance');\n        }\n    }\n    \n    public function canPay($amount) : bool {\n        return $this->balance >= $amount;\n    }\n}\n\nclass Bank extends Account {\n    protected $balance;\n\n    public function __construct(float $balance) {\n        $this->balance = $balance;\n    }\n}\n\nclass Paypal extends Account {\n    protected $balance;\n\n    public function __construct(float $balance) {\n        $this->balance = $balance;\n    }\n}\n\nclass Bitcoin extends Account {\n    protected $balance;\n\n    public function __construct(float $balance) {\n        $this->balance = $balance;\n    }\n}\n```\n\n现在我们用上面定义的环节（即银行 Bank，贝宝 Paypal，比特币 Bitcoin）准备链\n\n```php\n// 我们准备下面这样的链\n//      $bank->$paypal->$bitcoin\n//\n// 首选银行 bank\n//      如果银行 bank 不能支付则选择贝宝 paypal\n//      如果贝宝 paypal 不能支付则选择比特币 bit coin\n\n$bank = new Bank(100);          // 银行 Bank 有余额 100\n$paypal = new Paypal(200);      // 贝宝 Paypal 有余额 200\n$bitcoin = new Bitcoin(300);    // 比特币 Bitcoin 有余额 300\n\n$bank->setNext($paypal);\n$paypal->setNext($bitcoin);\n\n// 我们尝试用首选项支付，即银行 bank\n$bank->pay(259);\n\n// 输出将会是\n// ==============\n// Cannot pay using bank. Proceeding ..\n// Cannot pay using paypal. Proceeding ..: \n// Paid 259 using Bitcoin!\n```\n\n👮 命令模式\n-------\n\n现实例子\n> 一个普遍的例子是你在餐馆点餐。你 (即调用者 `Client`) 要求服务员 (即调用器 `Invoker`) 端来一些食物 (即命令 `Command`)，而服务员只是简单的把命令传达给知道怎么做菜的厨师 (即接收者 `Receiver`)。另一个例子是你 (即调用者 `Client`) 打开 (即命令 `Command`) 电视 (即接收者 `Receiver`)，通过使用遥控 (调用器 `Invoker`).\n\n白话\n> 允许你封装对象的功能。此模式的核心思想是分离调用者和接收者。\n\n维基百科\n> In object-oriented programming, the command pattern is a behavioral design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event at a later time. This information includes the method name, the object that owns the method and values for the method parameters.\n\n**代码例子**\n\n首先我们有一个接收者，包含了每一个可执行的功能的实现\n```php\n// Receiver\nclass Bulb {\n    public function turnOn() {\n        echo \"Bulb has been lit\";\n    }\n    \n    public function turnOff() {\n        echo \"Darkness!\";\n    }\n}\n```\n然后下面是每个命令执行的接口，之后我们就有了一个命令的集合\n```php\ninterface Command {\n    public function execute();\n    public function undo();\n    public function redo();\n}\n\n// Command\nclass TurnOn implements Command {\n    protected $bulb;\n    \n    public function __construct(Bulb $bulb) {\n        $this->bulb = $bulb;\n    }\n    \n    public function execute() {\n        $this->bulb->turnOn();\n    }\n    \n    public function undo() {\n        $this->bulb->turnOff();\n    }\n    \n    public function redo() {\n        $this->execute();\n    }\n}\n\nclass TurnOff implements Command {\n    protected $bulb;\n    \n    public function __construct(Bulb $bulb) {\n        $this->bulb = $bulb;\n    }\n    \n    public function execute() {\n        $this->bulb->turnOff();\n    }\n    \n    public function undo() {\n        $this->bulb->turnOn();\n    }\n    \n    public function redo() {\n        $this->execute();\n    }\n}\n```\n然后我们有了一个执行器 `Invoker`，调用者可以通过它执行命令\n```php\n// Invoker\nclass RemoteControl {\n    \n    public function submit(Command $command) {\n        $command->execute();\n    }\n}\n```\n最后我们看看可以如何使用\n```php\n$bulb = new Bulb();\n\n$turnOn = new TurnOn($bulb);\n$turnOff = new TurnOff($bulb);\n\n$remote = new RemoteControl();\n$remote->submit($turnOn); // Bulb has been lit!\n$remote->submit($turnOff); // Darkness!\n```\n\n命令模式也可以用来实现一个基础系统的事务。当你要一直在执行命令后马上维护日志。如果命令被正确执行，一切正常，否则沿日志迭代，一直对每个已执行的命令执行撤销 `undo` 。\n\n➿ 迭代器模式\n--------\n\n现实例子\n> 老式调频收音机是迭代器的好例子，用户可以在一些频道开始，然后使用前进或后退按钮来浏览每个频道。或者以 MP3 播放器或电视机为例，你可以按前进或后退按钮来浏览连续的频道。或者说，它们都提供了迭代连续的频道，歌曲或广播的接口。  \n\n白话\n> 它提供了一种方式来获得对象的元素，而不必暴露底层实现。\n\n维基百科\n> In object-oriented programming, the iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container's elements. The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.\n\n**代码例子**\n\n在 PHP 里，用 SPL (标准 PHP 库) 实现非常简单。翻译上面的广播例子。首先我们有了广播台 `RadioStation`\n\n```php\nclass RadioStation {\n    protected $frequency;\n\n    public function __construct(float $frequency) {\n        $this->frequency = $frequency;    \n    }\n    \n    public function getFrequency() : float {\n        return $this->frequency;\n    }\n}\n```\n下面是我们的迭代器\n\n```php\nuse Countable;\nuse Iterator;\n\nclass StationList implements Countable, Iterator {\n    /** @var RadioStation[] $stations */\n    protected $stations = [];\n    \n    /** @var int $counter */\n    protected $counter;\n    \n    public function addStation(RadioStation $station) {\n        $this->stations[] = $station;\n    }\n    \n    public function removeStation(RadioStation $toRemove) {\n        $toRemoveFrequency = $toRemove->getFrequency();\n        $this->stations = array_filter($this->stations, function (RadioStation $station) use ($toRemoveFrequency) {\n            return $station->getFrequency() !== $toRemoveFrequency;\n        });\n    }\n    \n    public function count() : int {\n        return count($this->stations);\n    }\n    \n    public function current() : RadioStation {\n        return $this->stations[$this->counter];\n    }\n    \n    public function key() {\n        return $this->counter;\n    }\n    \n    public function next() {\n        $this->counter++;\n    }\n    \n    public function rewind() {\n        $this->counter = 0;\n    }\n    \n    public function valid(): bool\n    {\n        return isset($this->stations[$this->counter]);\n    }\n}\n```\n然后可以这样使用\n```php\n$stationList = new StationList();\n\n$stationList->addStation(new Station(89));\n$stationList->addStation(new Station(101));\n$stationList->addStation(new Station(102));\n$stationList->addStation(new Station(103.2));\n\nforeach($stationList as $station) {\n    echo $station->getFrequency() . PHP_EOL;\n}\n\n$stationList->removeStation(new Station(89)); // Will remove station 89\n```\n\n👽 中介模式\n========\n\n现实例子\n> 一个普遍的例子是当你用手机和别人谈话，你和别人中间隔了一个电信网，你的声音穿过它而不是直接发出去。在这里，电信网就是一个中介。\n\n白话\n> 中介模式增加了一个第三方对象（叫做中介）来控制两个对象（叫做同事）间的交互。它帮助减少类彼此之间交流的耦合度。因为它们现在不需要知道彼此的实现。 \n\n维基百科\n> In software engineering, the mediator pattern defines an object that encapsulates how a set of objects interact. This pattern is considered to be a behavioral pattern due to the way it can alter the program's running behavior.\n\n**代码例子**\n\n下面是一个最简单的聊天室（即中介）的例子，用户（即同事）彼此发送信息。\n\n首先，我们有一个中介，即聊天室\n\n```php\n// 中介\nclass ChatRoom implements ChatRoomMediator {\n    public function showMessage(User $user, string $message) {\n        $time = date('M d, y H:i');\n        $sender = $user->getName();\n\n        echo $time . '[' . $sender . ']:' . $message;\n    }\n}\n```\n\n然后我们有用户，即同事\n```php\nclass User {\n    protected $name;\n    protected $chatMediator;\n\n    public function __construct(string $name, ChatRoomMediator $chatMediator) {\n        $this->name = $name;\n        $this->chatMediator = $chatMediator;\n    }\n    \n    public function getName() {\n        return $this->name;\n    }\n    \n    public function send($message) {\n        $this->chatMediator->showMessage($this, $message);\n    }\n}\n```\n然后是使用\n```php\n$mediator = new ChatRoom();\n\n$john = new User('John Doe', $mediator);\n$jane = new User('Jane Doe', $mediator);\n\n$john->send('Hi there!');\n$jane->send('Hey!');\n\n// 输出将会是\n// Feb 14, 10:58 [John]: Hi there!\n// Feb 14, 10:58 [Jane]: Hey!\n```\n\n💾 备忘录模式\n-------\n现实例子\n> 以计算器（即发起人）为例，无论什么时候你执行一些计算，最后的计算都会保存在内存（即备忘）里，这样你就能返回到这里，并且用一些按钮（即守护者）恢复。 \n\n白话\n> 备忘录模式捕捉和保存当前对象的状态，然后用一种平滑的方式恢复。\n\n维基百科\n> The memento pattern is a software design pattern that provides the ability to restore an object to its previous state (undo via rollback).\n\n当你要提供撤销方法时异常实用。\n\n**代码例子**\n\n让我们那编辑器为例，编辑器一直保存状态，在你需要的时候可以恢复。\n\n首先下面是我们的备忘录对象，可以保存编辑器状态\n\n```php\nclass EditorMemento {\n    protected $content;\n    \n    public function __construct(string $content) {\n        $this->content = $content;\n    }\n    \n    public function getContent() {\n        return $this->content;\n    }\n}\n```\n\n然后是我们的编辑器，即发起者，来使用备忘录对象\n\n```php\nclass Editor {\n    protected $content = '';\n    \n    public function type(string $words) {\n        $this->content = $this->content . ' ' . $words;\n    }\n    \n    public function getContent() {\n        return $this->content;\n    }\n    \n    public function save() {\n        return new EditorMemento($this->content);\n    }\n    \n    public function restore(EditorMemento $memento) {\n        $this->content = $memento->getContent();\n    }\n}\n```\n\n然后可以这样使用\n\n```php\n$editor = new Editor();\n\n// 输入一些东西\n$editor->type('This is the first sentence.');\n$editor->type('This is second.');\n\n// 保存状态到：This is the first sentence. This is second.\n$saved = $editor->save();\n\n// 输入些别的东西\n$editor->type('And this is third.');\n\n// 输出: Content before Saving\necho $editor->getContent(); // This is the first sentence. This is second. And this is third.\n\n// 恢复到上次保存状态\n$editor->restore($saved);\n\n$editor->getContent(); // This is the first sentence. This is second.\n```\n\n😎 观察者模式\n--------\n现实例子\n> 一个好的例子是求职者，他们订阅了一些工作发布网站，当有合适的工作机会时，他们会收到提醒。   \n\n白话\n> 定义了一个对象间的依赖，这样无论何时一个对象改变了状态，其他所有依赖者会收到提醒。\n\n维基百科\n> The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods.\n\n**代码例子**\n\n翻译上面的例子。首先我们有需要收到工作发布提醒的求职者\n```php\nclass JobPost {\n    protected $title;\n    \n    public function __construct(string $title) {\n        $this->title = $title;\n    }\n    \n    public function getTitle() {\n        return $this->title;\n    }\n}\n\nclass JobSeeker implements Observer {\n    protected $name;\n\n    public function __construct(string $name) {\n        $this->name = $name;\n    }\n\n    public function onJobPosted(JobPost $job) {\n        // Do something with the job posting\n        echo 'Hi ' . $this->name . '! New job posted: '. $job->getTitle();\n    }\n}\n```\n下面是求职者订阅的工作信息\n```php\nclass JobPostings implements Observable {\n    protected $observers = [];\n    \n    protected function notify(JobPost $jobPosting) {\n        foreach ($this->observers as $observer) {\n            $observer->onJobPosted($jobPosting);\n        }\n    }\n    \n    public function attach(Observer $observer) {\n        $this->observers[] = $observer;\n    }\n    \n    public function addJob(JobPost $jobPosting) {\n        $this->notify($jobPosting);\n    }\n}\n```\n然后可以这样使用\n```php\n// 创建订阅者\n$johnDoe = new JobSeeker('John Doe');\n$janeDoe = new JobSeeker('Jane Doe');\n\n// 创建发布者，绑定订阅者\n$jobPostings = new JobPostings();\n$jobPostings->attach($johnDoe);\n$jobPostings->attach($janeDoe);\n\n// 添加一个工作，看订阅者是否收到通知\n$jobPostings->addJob(new JobPost('Software Engineer'));\n\n// 输出\n// Hi John Doe! New job posted: Software Engineer\n// Hi Jane Doe! New job posted: Software Engineer\n```\n\n🏃 访问者模式\n-------\n现实例子\n> 假设一些人访问迪拜。他们需要一些方式（即签证）来进入迪拜。抵达后，他们可以去迪拜的任何地方，而不用申请许可或者跑腿；他们知道的地方都可以去。访问者模式可以让你这样做，它帮你添加可以访问的地方，然后他们可以访问尽可能多的地方而不用到处跑腿。\n\n白话\n> 访问者模式可以让你添加更多的操作到对象，而不用改变他们。\n    \n维基百科\n> In object-oriented programming and software engineering, the visitor design pattern is a way of separating an algorithm from an object structure on which it operates. A practical result of this separation is the ability to add new operations to existing object structures without modifying those structures. It is one way to follow the open/closed principle.\n\n**代码例子**\n\n让我们以动物园模拟器为例，在里面我们有一些动物，我们必须让他们叫。让我们用访问者模式来翻译\n\n```php\n// 被访者\ninterface Animal {\n    public function accept(AnimalOperation $operation);\n}\n\n// 访问者\ninterface AnimalOperation {\n    public function visitMonkey(Monkey $monkey);\n    public function visitLion(Lion $lion);\n    public function visitDolphin(Dolphin $dolphin);\n}\n```\nThen we have our implementations for the animals\n```php\nclass Monkey implements Animal {\n    \n    public function shout() {\n        echo 'Ooh oo aa aa!';\n    }\n\n    public function accept(AnimalOperation $operation) {\n        $operation->visitMonkey($this);\n    }\n}\n\nclass Lion implements Animal {\n    public function roar() {\n        echo 'Roaaar!';\n    }\n    \n    public function accept(AnimalOperation $operation) {\n        $operation->visitLion($this);\n    }\n}\n\nclass Dolphin implements Animal {\n    public function speak() {\n        echo 'Tuut tuttu tuutt!';\n    }\n    \n    public function accept(AnimalOperation $operation) {\n        $operation->visitDolphin($this);\n    }\n}\n```\n实现我们的访问者\n```php\nclass Speak implements AnimalOperation {\n    public function visitMonkey(Monkey $monkey) {\n        $monkey->shout();\n    }\n    \n    public function visitLion(Lion $lion) {\n        $lion->roar();\n    }\n    \n    public function visitDolphin(Dolphin $dolphin) {\n        $dolphin->speak();\n    }\n}\n```\n\n然后可以这样使用\n```php\n$monkey = new Monkey();\n$lion = new Lion();\n$dolphin = new Dolphin();\n\n$speak = new Speak();\n\n$monkey->accept($speak);    // Ooh oo aa aa!    \n$lion->accept($speak);      // Roaaar!\n$dolphin->accept($speak);   // Tuut tutt tuutt!\n```\n我们本可以简单地给动物加一个继承层来做到这点，但是这样每当我们要给动物增加新功能的时候，我们就不得不改变动物。但是现在我们不用改变他们。比如，我们要给动物增加一个跳的行为，我们可以通过简单地增加一个新的访问者\n\n```php\nclass Jump implements AnimalOperation {\n    public function visitMonkey(Monkey $monkey) {\n        echo 'Jumped 20 feet high! on to the tree!';\n    }\n    \n    public function visitLion(Lion $lion) {\n        echo 'Jumped 7 feet! Back on the ground!';\n    }\n    \n    public function visitDolphin(Dolphin $dolphin) {\n        echo 'Walked on water a little and disappeared';\n    }\n}\n```\n然后这样用\n```php\n$jump = new Jump();\n\n$monkey->accept($speak);   // Ooh oo aa aa!\n$monkey->accept($jump);    // Jumped 20 feet high! on to the tree!\n\n$lion->accept($speak);     // Roaaar!\n$lion->accept($jump);      // Jumped 7 feet! Back on the ground! \n\n$dolphin->accept($speak);  // Tuut tutt tuutt! \n$dolphin->accept($jump);   // Walked on water a little and disappeared\n```\n\n💡 策略模式\n--------\n\n现实例子\n> 考虑排序的例子，我们实现了冒泡排序，但是数据开始增长，冒泡排序变得很慢。为了应对这个，我们实现了快速排序。但现在尽管快速排序算法对大数据集表现更好，小数据集却很慢。为了应对这一点，我们实现一个策略，冒泡排序处理小数据集，快速排序处理大数据集。\n\n白话\n> 策略模式允许你基于情况选择算法或策略。\n\n维基百科\n> In computer programming, the strategy pattern (also known as the policy pattern) is a behavioural software design pattern that enables an algorithm's behavior to be selected at runtime.\n \n**代码例子**\n\n翻译我们上面的例子。首先我们有了策略接口和不同的策略实现\n\n```php\ninterface SortStrategy {\n    public function sort(array $dataset) : array; \n}\n\nclass BubbleSortStrategy implements SortStrategy {\n    public function sort(array $dataset) : array {\n        echo \"Sorting using bubble sort\";\n         \n        // Do sorting\n        return $dataset;\n    }\n} \n\nclass QuickSortStrategy implements SortStrategy {\n    public function sort(array $dataset) : array {\n        echo \"Sorting using quick sort\";\n        \n        // Do sorting\n        return $dataset;\n    }\n}\n```\n \n然后是实用策略的调用者\n```php\nclass Sorter {\n    protected $sorter;\n    \n    public function __construct(SortStrategy $sorter) {\n        $this->sorter = $sorter;\n    }\n    \n    public function sort(array $dataset) : array {\n        return $this->sorter->sort($dataset);\n    }\n}\n```\n然后可以这样使用\n```php\n$dataset = [1, 5, 4, 3, 2, 8];\n\n$sorter = new Sorter(new BubbleSortStrategy());\n$sorter->sort($dataset); // 输出 : Sorting using bubble sort\n\n$sorter = new Sorter(new QuickSortStrategy());\n$sorter->sort($dataset); // 输出 : Sorting using quick sort\n```\n\n💢 状态模式\n-----\n现实例子\n> 想象你在使用画图程序，你选择笔刷来画。现在笔刷根据选择的颜色改变自己的行为。即如果你选择红色，它就用红色画，如果是蓝色它就用蓝色等等。  \n\n白话\n> 他让你能类的状态改变时，改变其行为。\n\n维基百科\n> The state pattern is a behavioral software design pattern that implements a state machine in an object-oriented way. With the state pattern, a state machine is implemented by implementing each individual state as a derived class of the state pattern interface, and implementing state transitions by invoking methods defined by the pattern's superclass.\n> The state pattern can be interpreted as a strategy pattern which is able to switch the current strategy through invocations of methods defined in the pattern's interface.\n\n**代码例子**\n\n让我们以编辑器作为例子，它能让你改变文本的状态，比如你选择了加粗，它开始以加粗字体书写，如果选择倾斜，就以倾斜字体等等。\n\n首先，我们有状态接口和一些状态实现\n\n```php\ninterface WritingState {\n    public function write(string $words);\n}\n\nclass UpperCase implements WritingState {\n    public function write(string $words) {\n        echo strtoupper($words); \n    }\n} \n\nclass LowerCase implements WritingState {\n    public function write(string $words) {\n        echo strtolower($words); \n    }\n}\n\nclass Default implements WritingState {\n    public function write(string $words) {\n        echo $words;\n    }\n}\n```\n下面是我们的编辑器\n```php\nclass TextEditor {\n    protected $state;\n    \n    public function __construct(WritingState $state) {\n        $this->state = $state;\n    }\n    \n    public function setState(WritingState $state) {\n        $this->state = $state;\n    }\n    \n    public function type(string $words) {\n        $this->state->write($words);\n    }\n}\n```\n然后可以这样使用\n```php\n$editor = new TextEditor(new Default());\n\n$editor->type('First line');\n\n$editor->setState(new UpperCaseState());\n\n$editor->type('Second line');\n$editor->type('Third line');\n\n$editor->setState(new LowerCaseState());\n\n$editor->type('Fourth line');\n$editor->type('Fifth line');\n\n// 输出:\n// First line\n// SECOND LINE\n// THIRD LINE\n// fourth line\n// fifth line\n```\n\n📒 模板模式\n---------------\n\n现实例子\n> 假设我们要建房子。建造的步骤类似这样 \n> - 准备房子的地基\n> - 建造墙\n> - 建造房顶\n> - 然后是地板\n> 这些步骤步骤的顺序永远不会变，即你不能在建墙之前建屋顶，当时每个步骤都可以改变，比如墙可以是木头可以是聚酯或者石头。\n  \n白话\n> 模板模式定义了一个算法会如何执行的骨架，但把这些步骤的实现移交给子类。\n \n维基百科\n> In software engineering, the template method pattern is a behavioral design pattern that defines the program skeleton of an algorithm in an operation, deferring some steps to subclasses. It lets one redefine certain steps of an algorithm without changing the algorithm's structure.\n\n**代码例子**\n\n想象我们有一个构建工具帮我们测试，纠错，构建，生成构建报告（即代码报告，查错报告），然后把应用发布到测试服务器。\n\n首先是我们的基础类，它描述了构建算法的骨架\n```php\nabstract class Builder {\n    \n    // Template method \n    public final function build() {\n        $this->test();\n        $this->lint();\n        $this->assemble();\n        $this->deploy();\n    }\n    \n    public abstract function test();\n    public abstract function lint();\n    public abstract function assemble();\n    public abstract function deploy();\n}\n```\n\n以下是实现\n\n```php\nclass AndroidBuilder extends Builder {\n    public function test() {\n        echo 'Running android tests';\n    }\n    \n    public function lint() {\n        echo 'Linting the android code';\n    }\n    \n    public function assemble() {\n        echo 'Assembling the android build';\n    }\n    \n    public function deploy() {\n        echo 'Deploying android build to server';\n    }\n}\n\nclass IosBuilder extends Builder {\n    public function test() {\n        echo 'Running ios tests';\n    }\n    \n    public function lint() {\n        echo 'Linting the ios code';\n    }\n    \n    public function assemble() {\n        echo 'Assembling the ios build';\n    }\n    \n    public function deploy() {\n        echo 'Deploying ios build to server';\n    }\n}\n```\n然后可以这样使用\n\n```php\n$androidBuilder = new AndroidBuilder();\n$androidBuilder->build();\n\n// 输出:\n// Running android tests\n// Linting the android code\n// Assembling the android build\n// Deploying android build to server\n\n$iosBuilder = new IosBuilder();\n$iosBuilder->build();\n\n// 输出:\n// Running ios tests\n// Linting the ios code\n// Assembling the ios build\n// Deploying ios build to server\n```\n\n## 🚦 收尾了同志们\n\n终于收尾了。我会继续改进这篇文档，所以你或许需要 watch/star 这个仓库，先码后看。\n\n## 👬 Contribution\n\n- Report issues\n- Open pull request with improvements\n- Spread the word\n\n## 翻译\n[月球人](https://github.com/questionlin)\n\n## License\nMIT © [Kamran Ahmed](http://kamranahmed.info)\n","tags":["php"]},{"title":"hexo+github搭建博客最佳实践","url":"/posts/1528164408/","content":"\b在考察了多种方案后最终使用 hexo 搭起了博客，这篇文章写写我是怎么\b使用 hexo 和 github 来搭博客的。\n\n在官网主题那里选一个喜欢的主题，我找了一个有搜索引擎配置教学的。下载后放到 themes 文件夹。然后按照官方说明配置。\n\nhexo 不提供 markdown 编辑器，我使用 vscode，快捷键 command + k 再按 v 后可以打开一个实时预览标签页。\n\n我有一个特殊的需求，希望可以省略部署( hexo deploy) 这个步骤。这就要求博客源文件和生成文件放在一起。github pages 提供给用户专门建\b博客的项目只能放生成后的文件，这个方案否定。我的做法是：\n1. 把 _config.yml 里面的 public_dir 改为 docs\n2. 然后建一个普通的项目仓库，在 settings 里的 github pages Source 选为 master branch/docs folder。这里顺便把 Custom domain 改为自己的域名。\n3. 在域名 dns 设置里面添加 cname 指向 question.github.io\n4. 在文章顶部增加 id，值为 unix 时间戳，以优化 url\n\n用到的插件：\n- hexo-generator-search 用来支持\b搜索\n\n到此我的 hexo 博客就建好了，\b[项目仓库在这里](https://github.com/questionlin/blog)。比官方的方法少了一步。","tags":["hexo"]}]